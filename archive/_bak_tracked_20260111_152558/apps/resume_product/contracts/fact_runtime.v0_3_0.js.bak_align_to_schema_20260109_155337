// apps/resume_product/contracts/fact_runtime.v0_3_0.js
// Fact v0.3.0 runtime helpers: init / adapt / validate (minimal)

import { FACT_SCHEMA_V0_3_0 } from "./fact_schema.v0_3_0.js";

function iso(d = new Date()) { return d.toISOString(); }
function isNonEmptyStr(x) { return typeof x === "string" && x.trim().length > 0; }
function asArray(x) { return Array.isArray(x) ? x : (x == null ? [] : [x]); }

// ---- 1) Create empty Fact v0.3 ----
export function makeEmptyFactV03({ locale = "zh-CN" } = {}) {
  return {
    schema_version: FACT_SCHEMA_V0_3_0.version,
    created_at: iso(),
    updated_at: iso(),
    locale,
    privacy: { mode: "normal" },
    meta: { source: "manual", confidence: 1, gaps: [] },

    person: {
      name: "",
      location: { city: "", country: "" },
      contact: { email: "", phone: "", wechat: "", github: "", website: "", linkedin: "" },
      headline: "",
      summary: "",
      tags: [],
    },

    education: [],
    experience: [],
    projects: [],
    skills: { hard: [], soft: [], tools: [], languages: [] },
    certificates: [],
    awards: [],
    publications: [],
    volunteering: [],
    interests: [],
  };
}

// ---- 2) Normalize (fill meta, updated_at) ----
export function normalizeFactV03(input = {}, { locale = "zh-CN" } = {}) {
  const base = makeEmptyFactV03({ locale });
  const out = { ...base, ...(input || {}) };

  // deep-ish merges for common nested groups
  out.privacy = { ...(base.privacy || {}), ...(out.privacy || {}) };
  out.meta = { ...(base.meta || {}), ...(out.meta || {}) };
  out.person = { ...(base.person || {}), ...(out.person || {}) };
  out.person.location = { ...(base.person.location || {}), ...(out.person.location || {}) };
  out.person.contact = { ...(base.person.contact || {}), ...(out.person.contact || {}) };
  out.skills = { ...(base.skills || {}), ...(out.skills || {}) };

  out.schema_version = FACT_SCHEMA_V0_3_0.version;
  out.updated_at = iso();
  if (!out.created_at) out.created_at = iso();

  // force arrays
  out.education = asArray(out.education);
  out.experience = asArray(out.experience);
  out.projects = asArray(out.projects);

  // sanitize tags
  out.person.tags = asArray(out.person.tags).filter(isNonEmptyStr);

  return out;
}

// ---- 3) Adapt legacy Fact (current v0.2-ish structures) -> v0.3 ----
// Supports shapes like:
// - { basic, summary, skills, education, experience, projects } (your fact_profiles payload)
// - { person, education, experience, projects } (already new-ish)
export function adaptLegacyFactToV03(legacy = {}, { locale = "zh-CN" } = {}) {
  // already v0.3-ish
  if (legacy?.schema_version === FACT_SCHEMA_V0_3_0.version) return normalizeFactV03(legacy, { locale });

  const out = makeEmptyFactV03({ locale });

  // v0.2: basic
  const basic = legacy?.basic || {};
  const personName = basic?.name || legacy?.person?.name || "";
  out.person.name = String(personName || "");

  // contacts
  out.person.contact.email = String(basic?.email || legacy?.person?.contact?.email || "");
  out.person.contact.phone = String(basic?.phone || legacy?.person?.contact?.phone || "");
  out.person.contact.wechat = String(basic?.wechat || legacy?.person?.contact?.wechat || "");
  out.person.contact.github = String(basic?.github || legacy?.person?.contact?.github || "");
  out.person.contact.website = String(basic?.website || legacy?.person?.contact?.website || "");
  out.person.contact.linkedin = String(basic?.linkedin || legacy?.person?.contact?.linkedin || "");

  // location/headline/summary
  out.person.location.city = String(basic?.city || legacy?.person?.location?.city || "");
  out.person.location.country = String(basic?.country || legacy?.person?.location?.country || "");
  out.person.headline = String(basic?.title || legacy?.person?.headline || "");
  out.person.summary = String(legacy?.summary || legacy?.person?.summary || "");

  // v0.2 arrays
  out.education = asArray(legacy?.education);
  out.experience = asArray(legacy?.experience);
  out.projects = asArray(legacy?.projects);

  // skills (try best-effort)
  const skills = legacy?.skills;
  if (Array.isArray(skills)) {
    out.skills.hard = skills.filter(isNonEmptyStr);
  } else if (skills && typeof skills === "object") {
    out.skills = { ...out.skills, ...skills };
  }

  return normalizeFactV03(out, { locale });
}

// ---- 4) Minimal validation (only rules we already wrote in schema.rules) ----
export function validateFactV03(factInput) {
  const fact = normalizeFactV03(factInput || {});
  const errors = [];

  // locale gate: jp_only 只在日语环境启用
  const locale = (fact && fact.locale) ? String(fact.locale) : "zh-CN";
  const isJP = /^ja\b/i.test(locale) || /^ja-/i.test(locale) || /jp/i.test(locale);

  const rules = Array.isArray(FACT_SCHEMA_V0_3_0.rules) ? FACT_SCHEMA_V0_3_0.rules : [];

  const isNonEmpty = (v) => {
    if (v === null || v === undefined) return false;
    if (typeof v === "string") return v.trim().length > 0;
    if (Array.isArray(v)) return v.filter(isNonEmptyStr).length > 0;
    if (typeof v === "number") return !Number.isNaN(v);
    if (typeof v === "boolean") return true;
    if (typeof v === "object") return Object.keys(v).length > 0;
    return false;
  };

  const stripArr = (path) => String(path || "").replace(/\[\]$/g, "");

  const getByPath = (obj, path) => {
    try {
      if (!path) return undefined;
      const parts = String(path).split(".").filter(Boolean);
      let cur = obj;
      for (const k of parts) {
        if (cur == null) return undefined;
        cur = cur[k];
      }
      return cur;
    } catch {
      return undefined;
    }
  };

  const pushErr = (id, message, extra = {}) => {
    errors.push({ id: id || "RULE", message: message || "Validation failed", ...extra });
  };

  // ---- apply rules ----
  if (rules.length) {
    for (const r of rules) {
      if (!r || typeof r !== "object") continue;
      if (r.jp_only && !isJP) continue;

      const rid = r.id || "RULE";
      const msg = r.message || "Validation failed";

      if (r.type === "atLeastOne") {
        const paths = Array.isArray(r.paths) ? r.paths : [];
        const ok = paths.some((pp) => isNonEmpty(getByPath(fact, stripArr(pp))));
        if (!ok) pushErr(rid, msg, { paths });
        continue;
      }

      if (r.type === "minItems") {
        const min = (typeof r.min === "number") ? r.min : (parseInt(String(r.min || "0"), 10) || 0);
        const arr = getByPath(fact, stripArr(r.path));
        const n = Array.isArray(arr) ? arr.length : 0;
        if (n < min) pushErr(rid, msg, { path: r.path, min, got: n });
        continue;
      }

      if (r.type === "forEachRequired") {
        const list = getByPath(fact, stripArr(r.path));
        const required = Array.isArray(r.required) ? r.required : [];
        if (Array.isArray(list)) {
          list.forEach((item, idx) => {
            const missing = required.filter((pp) => !isNonEmpty(getByPath(item, stripArr(pp))));
            if (missing.length) pushErr(rid, msg, { index: idx, missing });
          });
        }
        continue;
      }

      if (r.type === "forEachMinSum") {
        const list = getByPath(fact, stripArr(r.path));
        const sums = Array.isArray(r.sums) ? r.sums : [];
        if (Array.isArray(list)) {
          list.forEach((item, idx) => {
            sums.forEach((s) => {
              const min = (typeof s.min === "number") ? s.min : (parseInt(String(s.min || "0"), 10) || 0);

              const aList = asArray(getByPath(item, stripArr(s.a)));
              const bList = asArray(getByPath(item, stripArr(s.b)));

              const aN = aList.filter(isNonEmptyStr).length;
              const bN = bList.filter((x) => {
                if (typeof x === "string") return isNonEmptyStr(x);
                if (x && typeof x === "object") return isNonEmptyStr(x.text);
                return false;
              }).length;

              if ((aN + bN) < min) pushErr(rid, msg, { index: idx, sum: aN + bN, min, a: s.a, b: s.b });
            });
          });
        }
        continue;
      }

      // unknown rule type: ignore
    }
  } else {
    // fallback: keep minimal behaviour if schema has no rules
    const email = fact?.person?.contact?.email || "";
    const phone = fact?.person?.contact?.phone || "";
    if (!isNonEmptyStr(email) && !isNonEmptyStr(phone)) {
      pushErr("L1_CONTACT_ONE_REQUIRED", "邮箱/电话至少填写一个");
    }
  }

  return { ok: errors.length === 0, errors, fact };
}
