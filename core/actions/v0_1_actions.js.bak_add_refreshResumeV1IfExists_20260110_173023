// Resume Product v0.1 — Actions (single source of truth writers)
// 目标：把 entry/scenario/fact/... 页面里散落的 dummy 写入逻辑，集中到这里

import { loadDB, saveDB, setActive } from "/core/storage/resume_db.js";
import RESUME_BASE_V1_ZH from "/core/template_engine/templates/resume_base_v1_zh.js";
import { composeResume } from "/core/resume_orchestrator/compose_resume.js";
import { adaptLegacyFactToV03, validateFactV03 } from "/apps/resume_product/contracts/fact_runtime.v0_3_0.js?v=20260110_154445";

function id(prefix) {
  return prefix + "_" + Math.random().toString(36).slice(2, 10);
}
function iso() {
  return new Date().toISOString();
}

export function resetResumeDB() {
  // ✅ 同时清空标准 key + legacy key（避免 split-brain）
  localStorage.removeItem("RESUME_DB_V1");
  localStorage.removeItem("RESUME_DB");

  // 写入日志也一起清
  localStorage.removeItem("RESUME_WRITE_LOG_V1");
}

export function ensureSession() {
  const db = loadDB();
  db.active = db.active || {};
  db.sessions = db.sessions || {};

  const cur = db.active.session_id;
  if (cur && db.sessions?.[cur]) return cur;

  const sid = cur || id("s");
  db.sessions[sid] = db.sessions[sid] || { id: sid, created_at: iso(), scenario_id: null, role_id: null };
  db.active.session_id = sid;

  // ✅ 原子写入：同一个 db 里同时写 sessions + active，再 save 一次
  saveDB(db);
  return sid;
}

export function writeScenarioDummy(payload = {}) {
  // 1) 先确保 session
  const sid = ensureSession();

  // 2) 再拿最新 db（避免覆盖）
  const db = loadDB();

  // 3) 复用已有 scenario_id（允许反复保存），否则新建
  const scId = db?.active?.scenario_id || id("sc");

  db.scenarios = db.scenarios || {};

  // 4) 最小可用 payload（后续再扩展为真实表单）
  const merged = {
    scenario: payload?.scenario || "default",
    note: payload?.note || "",
    ...payload,
  };

 db.scenarios[scId] = {
  id: scId,
  session_id: sid,
  created_at: iso(),
  payload: merged,
};

// ✅ 兼容：某些逻辑可能读 scenario_profiles
db.scenario_profiles = db.scenario_profiles || {};
db.scenario_profiles[scId] = db.scenarios[scId];

// ✅ 双保险 A：直接写进同一份 db.active（这一轮 save 就带上）
db.active = db.active || {};
db.active.session_id = sid;
db.active.scenario_id = scId;
// ✅ 再补一份“旧/另一套命名”，不管状态机读哪套都能过
db.active.scenario_profile_id = scId;
  // ✅ 再写入 session（deriveStatus 也会读 session，防止 active 被别处覆盖导致里程碑回退）
  db.sessions = db.sessions || {};
  db.sessions[sid] = db.sessions[sid] || { id: sid, created_at: iso() };
  db.sessions[sid].scenario_id = scId;
  db.sessions[sid].scenario_profile_id = scId;


saveDB(db);

// ✅ 双保险 B：再用 setActive 写一次（如果别处依赖 write_log）
setActive(loadDB(), { scenario_id: scId, scenario_profile_id: scId });

return scId;
}




export function writeFactProfileDummy(payload = {}) {
  // 1) 先确保 session
  const sid = ensureSession();

  // 2) 拿最新 db
  const db = loadDB();

  // 3) upsert：复用 active 的 fpId；否则新建
  const fpId = db?.active?.fact_profile_id || id("fp");

  db.fact_profiles = db.fact_profiles || {};
  const prev = db.fact_profiles[fpId] || null;

  // ✅ payload 回退：如果按钮触发时 payload 为空/缺失，就用当前 fp 已保存的 payload
  // （结构化表单可能已经自动写入 db.fact_profiles[fpId].payload，但没有同步到 __STEP_PAYLOAD__）
  const isEmptyObj = (x) => x && typeof x === "object" && !Array.isArray(x) && Object.keys(x).length === 0;
  const existingPayload = db?.fact_profiles?.[fpId]?.payload;
  if ((payload == null || isEmptyObj(payload)) && existingPayload) {
    payload = existingPayload;
  }


    // 4) 统一为 v0.3.0 payload（不做启发式判断：统一走 adapter，保证 basic.email/phone -> person.contact）
  const legacy = (payload && typeof payload === "object") ? payload : {};
  let v03 = adaptLegacyFactToV03(legacy, { locale: "zh-CN" });

// 5) 补齐 meta 字段（保持可追溯）
  const now = iso();
  v03 = (v03 && typeof v03 === "object") ? v03 : {};
  v03.locale = v03.locale || "zh-CN";
  v03.created_at = v03.created_at || (prev?.payload?.created_at) || now;
  v03.updated_at = now;
    console.log("[FACT][WRITE][V03]", {
      schema_version: v03?.schema_version,
      v03_email: v03?.person?.contact?.email,
      v03_phone: v03?.person?.contact?.phone,
      v03_person_has: !!v03?.person,
    });


  // 6) L1 校验：不通过就抛错（UI 会弹窗）
  const vr = validateFactV03(v03);
if (!vr?.ok) {
    const msg =
      (vr?.errors && Array.isArray(vr.errors) && vr.errors.length)
        ? vr.errors.map(e => (e?.message || String(e))).slice(0, 3).join("；")
        : "unknown";
    throw new Error("FACT 校验失败：" + msg);
  }
  // ✅ 保存 normalize 后的版本（schema_version/嵌套结构以 contract 为准）
  v03 = (vr && vr.fact) ? vr.fact : v03;

  // 7) 写入 fact_profiles（保留首次 created_at）
  db.fact_profiles[fpId] = {
    id: fpId,
    session_id: sid,
    created_at: prev?.created_at || now,
    updated_at: now,
    payload: v03,
  };

  // 8) 写回 active（setActive 内部会 saveDB）
  setActive(db, { fact_profile_id: fpId });
  return fpId;
}
export function writeResumeV1Dummy() {
  const sid = ensureSession();

  // 关键：拿“最新 db”，避免旧 db 覆盖 session/active
  const db = loadDB();

   // 复用已有 V1（避免每次生成一个新 rv，导致后续链路/预览对不上）
const existing =
  db?.active?.resume_version_id ||
  db?.sessions?.[sid]?.resume_version_id ||
  null;

const rv = existing || id("rv");

  // ✅ 先拿到 fpId（否则下面会 ReferenceError）
  const fpId = db?.active?.fact_profile_id || null;

  // ✅ fact_profiles 的真实数据在 fp.payload
  const fp = fpId ? db?.fact_profiles?.[fpId] : null;
  const fact_profile = fp ? (fp.payload || fp._raw || fp) : {};

const hasTarget = !!(db?.active?.target_profile_id || db?.sessions?.[sid]?.target_profile_id);
const hasKash = !!(db?.active?.claimed_kash_id || db?.sessions?.[sid]?.claimed_kash_id);
const mode = (hasTarget && hasKash) ? "TARGET_KASH" : "BASE";

const out = composeResume({ mode, db });
const content = (out?.render?.base_txt || "").toString();
const meta = out?.meta || {};

  // 把 content 按 section_map 切回 sections（兼容你现在的 DB 结构）
  const sections = {};
  const section_map = meta?.section_map || {};
  for (const key of Object.keys(section_map)) {
    const { start, end } = section_map[key] || {};
    if (typeof start === "number" && typeof end === "number" && end > start) {
      sections[key] = content.slice(start, end).trim();
    }
  }

  db.resume_versions = db.resume_versions || {};
  db.resume_versions[rv] = {
    id: rv,
    session_id: sid,
    type: "V1_BASE",
    created_at: iso(),
    source: { fact_profile_id: fpId },
    policy_snapshot: {},

    // 新增：完整文本（后面预览/导出更好用）
    content,

    // 保留：你现有结构
    sections,
    section_hash: {},

    meta: {
      // composer 产出的结构化元信息
      ...meta,

      // 你原来就有的字段（先保留）
      locale: "zh-CN",
      tone: "formal",
      print_style_id: "print_v0_1_a4",
    },
  };

    // ✅ 原子写入：active + session 都要写（deriveStatus / milestones 会读 session）
db.active = db.active || {};
db.active.session_id = sid;
db.active.resume_version_id = rv;

db.sessions = db.sessions || {};
db.sessions[sid] = db.sessions[sid] || { id: sid };
db.sessions[sid].resume_version_id = rv;

saveDB(db);
return rv;
}


// ✅ role_target step: 目标岗位输入（最小可用）
// - 写入 db.role_targets[rtId].payload
// - 同步 active.role_target_id + session.role_target_id
export function writeRoleTargetDummy(payload = {}) {
  const sid = ensureSession();
  const db = loadDB();

  const existing =
    db?.active?.role_target_id ||
    (sid && db?.sessions?.[sid]?.role_target_id) ||
    null;

  const rtId = existing || id("rt");

  db.role_targets = db.role_targets || {};
  const prev = db.role_targets[rtId] || null;

  const merged = {
    role_text: (payload?.role_text || "").toString().trim(),
    role_note: (payload?.role_note || "").toString().trim(),
    meta: payload?.meta || { source: "role_target.v0_2_4" },
    ...payload,
  };

  db.role_targets[rtId] = {
    id: rtId,
    session_id: sid,
    created_at: prev?.created_at || iso(),
    updated_at: iso(),
    payload: merged,
  };

  db.active = db.active || {};
  db.active.session_id = sid;
  db.active.role_target_id = rtId;

  db.sessions = db.sessions || {};
  db.sessions[sid] = db.sessions[sid] || { id: sid, created_at: iso() };
  db.sessions[sid].role_target_id = rtId;

  saveDB(db);
  return rtId;
}


export function writeTargetProfileDummy(payload = {}) {
  // 1) 先确保 session
  const sid = ensureSession();

  // 2) 再拿最新 db
  const db = loadDB();

  // 3) 复用已有 id（允许反复保存同一份 target）
  const existing =
    db?.active?.target_profile_id ||
    db?.sessions?.[sid]?.target_profile_id ||
    null;

  const tid = existing || id("t");

  // 4) 写表（主表：target_profiles）
  db.target_profiles = db.target_profiles || {};
  db.target_profiles[tid] = {
    id: tid,
    session_id: sid,
    created_at: iso(),
    payload: {
      ...payload,
      note: payload?.note || "",
    },
  };

  // 5) 兼容（如果旧逻辑/hasId 读 targets）
  db.targets = db.targets || {};
  db.targets[tid] = db.target_profiles[tid];

  // 6) 原子写回 active + session（deriveStatus 可能读 session 上的 id）
  db.active = db.active || {};
  db.active.session_id = sid;
  db.active.target_profile_id = tid;

  db.sessions = db.sessions || {};
  db.sessions[sid] = db.sessions[sid] || { id: sid };
  db.sessions[sid].target_profile_id = tid;

  saveDB(db);
  return tid;
}

export function writeRoleDummy(payload = {}) {
  const sid = ensureSession();
  const db = loadDB();

  // ✅ 复用已有 role_id（允许反复保存）
  const rid =
    db?.active?.role_id ||
    db?.sessions?.[sid]?.role_id ||
    id("role");

  // ✅ roles 表（若其他地方需要 hasId(db,"roles",...) 也能用）
  db.roles = db.roles || {};
  db.roles[rid] = {
    id: rid,
    session_id: sid,
    created_at: iso(),
    payload: {
      ...payload,
      note: payload?.note || "",
    },
  };

  // ✅ 状态机口径：HAS_ROLE 看 session.role_id
  db.sessions = db.sessions || {};
  db.sessions[sid] = db.sessions[sid] || { id: sid };
  db.sessions[sid].role_id = rid;

  // ✅ 顺手同步 active（方便页面/调试读取）
  db.active = db.active || {};
  db.active.session_id = sid;
  db.active.role_id = rid;

  saveDB(db);
  return rid;
}


export function writeClaimedKashDummy() {
  const db = loadDB();
  const sid = ensureSession();
  const kid = id("kash");
  db.claimed_kash[kid] = { id: kid, session_id: sid, created_at: iso(), payload: {} };
  saveDB(db);
  setActive(loadDB(), { claimed_kash_id: kid });
  return kid;
}
export function writeResumeV2Dummy(payload = {}) {
  const sid = ensureSession();
  const db = loadDB();

  // 复用已有 id（允许反复保存同一份 V2）
  const existing =
    db?.active?.resume_v2_id ||
    db?.sessions?.[sid]?.resume_v2_id ||
    null;

  const rv2Id = existing || id("rv2");

  // ✅ Gate2：只要 Target + ClaimedKash 都存在，就用 TARGET_KASH
  const hasTarget = !!(db?.active?.target_profile_id || db?.sessions?.[sid]?.target_profile_id);
  const hasKash = !!(db?.active?.claimed_kash_id || db?.sessions?.[sid]?.claimed_kash_id);
  const mode = (hasTarget && hasKash) ? "TARGET_KASH" : "BASE";

  // 生成（当用户没手填内容时）
  const out = composeResume({ mode, db });
  const generated = (out?.render?.base_txt || "").toString();

  // 用户优先（用户在 V2 文本框里编辑过，就保存用户文本）
  const userText = (payload?.content || "").toString();
  const content = userText.trim() ? userText : generated;
  const meta = out?.meta || {};

  db.resume_v2s = db.resume_v2s || {};
  db.resume_v2s[rv2Id] = {
    id: rv2Id,
    session_id: sid,
    created_at: iso(),
    mode,
    source: {
      fact_profile_id: db?.active?.fact_profile_id || null,
      resume_version_id: db?.active?.resume_version_id || null,
      target_profile_id: db?.active?.target_profile_id || null,
      claimed_kash_id: db?.active?.claimed_kash_id || null,
    },
    content,
    meta: { ...meta, mode, locale: "zh-CN" },
  };

  // 原子写 active + session
  db.active = db.active || {};
  db.active.session_id = sid;
  db.active.resume_v2_id = rv2Id;

  db.sessions = db.sessions || {};
  db.sessions[sid] = db.sessions[sid] || { id: sid };
  db.sessions[sid].resume_v2_id = rv2Id;

  saveDB(db);
  return rv2Id;
}

export function writeAssessmentDummy(payload = {}) {
  // 1) 先确保 session 已经写入（可能会触发 saveDB）
  const sid = ensureSession();

  // 2) 关键：再 load 一次，拿到“最新的 db”，避免旧 db 覆盖掉 session
  const db = loadDB();

  const aid = id("a");

  db.assessments = db.assessments || {};
  db.assessments[aid] = {
    id: aid,
    session_id: sid,
    created_at: iso(),
    source: "MYGIFT_PLACEHOLDER",
    payload,
    meta: {
      version: "4.1.0",
      adapter: "from_mygift_profile_v4_1@TODO",
    },
  };

  db.active = db.active || {};
  // 双保险：把 session_id 也写回 active，避免入口判断丢失
  db.active.session_id = sid;
  db.active.assessment_id = aid;

// ✅ 让状态机能认：把 V2 里程碑写到 session 上（和 scenario 同一套路）
db.sessions = db.sessions || {};
db.sessions[sid] = db.sessions[sid] || { id: sid, created_at: iso() };
const rv2Id = db?.active?.resume_v2_id || db?.sessions?.[sid]?.resume_v2_id || null;
db.sessions[sid].resume_v2_id = rv2Id;     // 关键
refreshResumeV1IfExists(db, sid);
  
  refreshResumeV1IfExists(db, sid);
  saveDB(db);
  return aid;
}

export function writeFitDummy(payload = {}) {
  // 1) 先确保 session 已经存在
  const sid = ensureSession();

  // 2) 再 load 一次，拿“最新 db”，避免旧 db 覆盖
  const db = loadDB();

  const fid = id("fit");

  db.fit_results = db.fit_results || {};
  db.fit_results[fid] = {
    id: fid,
    session_id: sid,
    created_at: iso(),
    source: {
      assessment_id: db?.active?.assessment_id || null,
      target_profile_id: db?.active?.target_profile_id || null,
      role_id: db?.sessions?.[sid]?.role_id || null,
    },
    payload,
    meta: {
      version: "0.1.0",
    },
  };

  // 双保险：写回 session_id + fit_result_id
  db.active = db.active || {};
  db.active.session_id = sid;
  db.active.fit_result_id = fid;

  saveDB(db);
  return fid;
}

export function writeResumeV3Dummy(payload = {}) {
  // 1) 先确保 session
  const sid = ensureSession();

  // 2) 再拿最新 db（避免覆盖）
  const db = loadDB();

  // 3) 复用已有 id（允许反复保存），否则新建
  const rv3Id = db?.active?.resume_v3_id || id("rv3");

  // 4) 最小可用内容：优先 payload.content
  const content = (payload?.content ?? "").toString();

  // 5) ✅ 状态机要求的“主表”必须叫 resume_v3
  db.resume_v3 = db.resume_v3 || {};
  db.resume_v3[rv3Id] = {
    id: rv3Id,
    session_id: sid,
    created_at: iso(),
    content,
    payload: { ...payload, content },
    source: {
      resume_v2_id: db?.active?.resume_v2_id || null,
      resume_version_id: db?.active?.resume_version_id || null,
    },
  };

  // 6) 兼容别处可能读取的表（可留可删，但留着最稳）
  db.resume_v3s = db.resume_v3s || {};
  db.resume_v3s[rv3Id] = db.resume_v3[rv3Id];

  // 7) ✅ 同一个 db 里原子写 active + session，再一次性 save
  db.active = db.active || {};
  db.active.session_id = sid;
  db.active.resume_v3_id = rv3Id;

  db.sessions = db.sessions || {};
  db.sessions[sid] = db.sessions[sid] || {};
  db.sessions[sid].resume_v3_id = rv3Id;

  saveDB(db);
  return rv3Id;
}
export function writePlan90dDummy(payload = {}) {
  const db = loadDB();
  const sid = ensureSession();

  // ✅ 复用已有 id（允许反复保存同一份 90d 计划）
  const existing =
    db?.active?.plan_90d_id ||
    db?.sessions?.[sid]?.plan_90d_id ||
    null;

  const pid = existing || id("p90");

  db.plan_90d = db.plan_90d || {};
  db.plan_90d[pid] = {
    id: pid,
    session_id: sid,
    created_at: iso(),
    payload,
    meta: { version: "v0.1" },
  };

  // ✅ 兼容：有些 hasId/状态机实现会找 plan_90ds（复数）
db.plan_90ds = db.plan_90ds || {};
db.plan_90ds[pid] = db.plan_90d[pid];

  // ✅ 写回 active（状态机依赖）
  db.active = db.active || {};
  db.active.session_id = sid;
  db.active.plan_90d_id = pid;

  // ✅ 同步写回 session（deriveStatus 可能读 session 上的 id）
  db.sessions = db.sessions || {};
  db.sessions[sid] = db.sessions[sid] || { id: sid };
  db.sessions[sid].plan_90d_id = pid;

  saveDB(db);
  return pid;
}
// ✅ 兼容：页面找的是 writePlan90DDummy（双 D），这里做别名导出
export function writePlan90DDummy(payload = {}) {
  return writePlan90dDummy(payload);
}

// ================================
// STEP writer: KASH (dummy)
// required_step: claimed_kash
// ================================
export function writeKashDummy(payload = {}) {
  const sid = ensureSession();
  const db = loadDB();

  const kid = db?.active?.claimed_kash_id || id("kash");

  db.claimed_kash = db.claimed_kash || {};
  db.claimed_kash[kid] = {
    id: kid,
    session_id: sid,
    created_at: iso(),
    payload: {
      ...payload,
      note: payload?.note || "",
    },
  };
  // ✅ 关键：先把 claimed_kash_id 写进“同一个 db 对象”，再 refresh V1
  db.active = db.active || {};
  db.active.claimed_kash_id = kid;

  db.sessions = db.sessions || {};
  db.sessions[sid] = db.sessions[sid] || { id: sid };
  db.sessions[sid].claimed_kash_id = kid;
  refreshResumeV1IfExists(db, sid);
  saveDB(db);
  

  // 状态机/流程用：写回 active
  setActive(loadDB(), { claimed_kash_id: kid });

  return kid;
}

export function writeExportReadyDummy(payload = {}) {
  // 1) 先确保 session 已经存在
  const sid = ensureSession();

  // 2) 再 load 最新 DB，避免旧 db 覆盖其它里程碑
  const db = loadDB();

  // 3) 必须关联当前简历版本（可追溯）
  const resume_version_id = db?.active?.resume_version_id || null;

  if (!resume_version_id || !db?.resume_versions?.[resume_version_id]?.content) {
    throw new Error("[writeExportReadyDummy] missing resume_version_id/content. Please generate Resume V1 first.");
  }

  // 4) 标记导出已生成（状态机使用）
  db.export_ready = true;

  // 5) 生成 export_ready 产物（有 id，便于 deriveStatus/追溯）
const export_ready_id = id("er");

db.export_readies = db.export_readies || {};
db.export_readies[export_ready_id] = {
  id: export_ready_id,
  session_id: sid,
  created_at: iso(),
  source: {
    resume_version_id,
    fact_profile_id: db?.active?.fact_profile_id || null,
    role_id: db?.active?.role_id || db?.sessions?.[sid]?.role_id || null,
  },
  payload,
  meta: {
    version: "0.1.0",
    format: payload?.format || "txt",
    mime: payload?.mime || "text/plain",
    action: payload?.action || "mark_export_ready",
  },
};

// 兼容旧字段（你原来的继续保留）
db.export_snapshot = db.export_readies[export_ready_id];

// ✅ 关键：把产物 id 写回 active（让 deriveStatus 能命中）
setActive(db, { export_ready_id });

  // 6) 兼容你现有字段（如果别处已经在读它，就继续保留）
  db.export_ready_meta = {
    t: iso(),
    payload,
    session_id: sid,
    resume_version_id,
  };

  // 7) 双保险：确保 active.session_id 不丢
  db.active = db.active || {};
  db.active.session_id = sid;

  saveDB(db);
  return true;
}
// ================================
// STEP writer: KASH (dummy)
// required_step: claimed_kash
// ================================
// ================================
// STEP writer: Plan 90D (v0.1)
// required_step: plan_90d
// ================================
